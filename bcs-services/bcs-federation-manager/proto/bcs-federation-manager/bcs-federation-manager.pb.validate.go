// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/bcs-federation-manager/bcs-federation-manager.proto

package federationmanager

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateFederationClusterNamespaceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateFederationClusterNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateFederationClusterNamespaceRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// CreateFederationClusterNamespaceRequestMultiError, or nil if none found.
func (m *CreateFederationClusterNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFederationClusterNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for Namespace

	// no validation rules for Annotations

	if all {
		switch v := interface{}(m.GetClusterAffinity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateFederationClusterNamespaceRequestValidationError{
					field:  "ClusterAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateFederationClusterNamespaceRequestValidationError{
					field:  "ClusterAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterAffinity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateFederationClusterNamespaceRequestValidationError{
				field:  "ClusterAffinity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetQuotaList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateFederationClusterNamespaceRequestValidationError{
						field:  fmt.Sprintf("QuotaList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateFederationClusterNamespaceRequestValidationError{
						field:  fmt.Sprintf("QuotaList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateFederationClusterNamespaceRequestValidationError{
					field:  fmt.Sprintf("QuotaList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Creator

	if len(errors) > 0 {
		return CreateFederationClusterNamespaceRequestMultiError(errors)
	}

	return nil
}

// CreateFederationClusterNamespaceRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateFederationClusterNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateFederationClusterNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFederationClusterNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFederationClusterNamespaceRequestMultiError) AllErrors() []error { return m }

// CreateFederationClusterNamespaceRequestValidationError is the validation
// error returned by CreateFederationClusterNamespaceRequest.Validate if the
// designated constraints aren't met.
type CreateFederationClusterNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFederationClusterNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFederationClusterNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateFederationClusterNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFederationClusterNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFederationClusterNamespaceRequestValidationError) ErrorName() string {
	return "CreateFederationClusterNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFederationClusterNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFederationClusterNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFederationClusterNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFederationClusterNamespaceRequestValidationError{}

// Validate checks the field values on NamespaceSubClusterAffinity with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NamespaceSubClusterAffinity) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamespaceSubClusterAffinity with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NamespaceSubClusterAffinityMultiError, or nil if none found.
func (m *NamespaceSubClusterAffinity) ValidateAll() error {
	return m.validate(true)
}

func (m *NamespaceSubClusterAffinity) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mode

	if m.LabelSelector != nil {

		if all {
			switch v := interface{}(m.GetLabelSelector()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NamespaceSubClusterAffinityValidationError{
						field:  "LabelSelector",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NamespaceSubClusterAffinityValidationError{
						field:  "LabelSelector",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLabelSelector()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NamespaceSubClusterAffinityValidationError{
					field:  "LabelSelector",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NamespaceSubClusterAffinityMultiError(errors)
	}

	return nil
}

// NamespaceSubClusterAffinityMultiError is an error wrapping multiple
// validation errors returned by NamespaceSubClusterAffinity.ValidateAll() if
// the designated constraints aren't met.
type NamespaceSubClusterAffinityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceSubClusterAffinityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceSubClusterAffinityMultiError) AllErrors() []error { return m }

// NamespaceSubClusterAffinityValidationError is the validation error returned
// by NamespaceSubClusterAffinity.Validate if the designated constraints
// aren't met.
type NamespaceSubClusterAffinityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceSubClusterAffinityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceSubClusterAffinityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceSubClusterAffinityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceSubClusterAffinityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceSubClusterAffinityValidationError) ErrorName() string {
	return "NamespaceSubClusterAffinityValidationError"
}

// Error satisfies the builtin error interface
func (e NamespaceSubClusterAffinityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespaceSubClusterAffinity.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceSubClusterAffinityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceSubClusterAffinityValidationError{}

// Validate checks the field values on LabelSelector with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LabelSelector) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabelSelector with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LabelSelectorMultiError, or
// nil if none found.
func (m *LabelSelector) ValidateAll() error {
	return m.validate(true)
}

func (m *LabelSelector) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MatchLabels

	for idx, item := range m.GetMatchExpressions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LabelSelectorValidationError{
						field:  fmt.Sprintf("MatchExpressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LabelSelectorValidationError{
						field:  fmt.Sprintf("MatchExpressions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LabelSelectorValidationError{
					field:  fmt.Sprintf("MatchExpressions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LabelSelectorMultiError(errors)
	}

	return nil
}

// LabelSelectorMultiError is an error wrapping multiple validation errors
// returned by LabelSelector.ValidateAll() if the designated constraints
// aren't met.
type LabelSelectorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelSelectorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelSelectorMultiError) AllErrors() []error { return m }

// LabelSelectorValidationError is the validation error returned by
// LabelSelector.Validate if the designated constraints aren't met.
type LabelSelectorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelSelectorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelSelectorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelSelectorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelSelectorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelSelectorValidationError) ErrorName() string { return "LabelSelectorValidationError" }

// Error satisfies the builtin error interface
func (e LabelSelectorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabelSelector.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelSelectorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelSelectorValidationError{}

// Validate checks the field values on LabelSelectorRequirement with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LabelSelectorRequirement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabelSelectorRequirement with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LabelSelectorRequirementMultiError, or nil if none found.
func (m *LabelSelectorRequirement) ValidateAll() error {
	return m.validate(true)
}

func (m *LabelSelectorRequirement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Operator

	if len(errors) > 0 {
		return LabelSelectorRequirementMultiError(errors)
	}

	return nil
}

// LabelSelectorRequirementMultiError is an error wrapping multiple validation
// errors returned by LabelSelectorRequirement.ValidateAll() if the designated
// constraints aren't met.
type LabelSelectorRequirementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelSelectorRequirementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelSelectorRequirementMultiError) AllErrors() []error { return m }

// LabelSelectorRequirementValidationError is the validation error returned by
// LabelSelectorRequirement.Validate if the designated constraints aren't met.
type LabelSelectorRequirementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelSelectorRequirementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelSelectorRequirementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelSelectorRequirementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelSelectorRequirementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelSelectorRequirementValidationError) ErrorName() string {
	return "LabelSelectorRequirementValidationError"
}

// Error satisfies the builtin error interface
func (e LabelSelectorRequirementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabelSelectorRequirement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelSelectorRequirementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelSelectorRequirementValidationError{}

// Validate checks the field values on K8SResource with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *K8SResource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on K8SResource with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in K8SResourceMultiError, or
// nil if none found.
func (m *K8SResource) ValidateAll() error {
	return m.validate(true)
}

func (m *K8SResource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ResourceName

	// no validation rules for ResourceQuantity

	if len(errors) > 0 {
		return K8SResourceMultiError(errors)
	}

	return nil
}

// K8SResourceMultiError is an error wrapping multiple validation errors
// returned by K8SResource.ValidateAll() if the designated constraints aren't met.
type K8SResourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m K8SResourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m K8SResourceMultiError) AllErrors() []error { return m }

// K8SResourceValidationError is the validation error returned by
// K8SResource.Validate if the designated constraints aren't met.
type K8SResourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e K8SResourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e K8SResourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e K8SResourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e K8SResourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e K8SResourceValidationError) ErrorName() string { return "K8SResourceValidationError" }

// Error satisfies the builtin error interface
func (e K8SResourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sK8SResource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = K8SResourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = K8SResourceValidationError{}

// Validate checks the field values on Quota with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Quota) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Quota with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QuotaMultiError, or nil if none found.
func (m *Quota) ValidateAll() error {
	return m.validate(true)
}

func (m *Quota) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Attributes

	for idx, item := range m.GetResourceList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QuotaValidationError{
						field:  fmt.Sprintf("ResourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QuotaValidationError{
						field:  fmt.Sprintf("ResourceList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QuotaValidationError{
					field:  fmt.Sprintf("ResourceList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Annotations

	if m.OriginK8SData != nil {
		// no validation rules for OriginK8SData
	}

	if len(errors) > 0 {
		return QuotaMultiError(errors)
	}

	return nil
}

// QuotaMultiError is an error wrapping multiple validation errors returned by
// Quota.ValidateAll() if the designated constraints aren't met.
type QuotaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QuotaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QuotaMultiError) AllErrors() []error { return m }

// QuotaValidationError is the validation error returned by Quota.Validate if
// the designated constraints aren't met.
type QuotaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QuotaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QuotaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QuotaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QuotaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QuotaValidationError) ErrorName() string { return "QuotaValidationError" }

// Error satisfies the builtin error interface
func (e QuotaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQuota.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QuotaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QuotaValidationError{}

// Validate checks the field values on CreateFederationClusterNamespaceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateFederationClusterNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateFederationClusterNamespaceResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateFederationClusterNamespaceResponseMultiError, or nil if none found.
func (m *CreateFederationClusterNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFederationClusterNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateFederationClusterNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateFederationClusterNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateFederationClusterNamespaceResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return CreateFederationClusterNamespaceResponseMultiError(errors)
	}

	return nil
}

// CreateFederationClusterNamespaceResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateFederationClusterNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateFederationClusterNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFederationClusterNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFederationClusterNamespaceResponseMultiError) AllErrors() []error { return m }

// CreateFederationClusterNamespaceResponseValidationError is the validation
// error returned by CreateFederationClusterNamespaceResponse.Validate if the
// designated constraints aren't met.
type CreateFederationClusterNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFederationClusterNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFederationClusterNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateFederationClusterNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFederationClusterNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFederationClusterNamespaceResponseValidationError) ErrorName() string {
	return "CreateFederationClusterNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFederationClusterNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFederationClusterNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFederationClusterNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFederationClusterNamespaceResponseValidationError{}

// Validate checks the field values on UpdateFederationClusterNamespaceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UpdateFederationClusterNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpdateFederationClusterNamespaceRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// UpdateFederationClusterNamespaceRequestMultiError, or nil if none found.
func (m *UpdateFederationClusterNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFederationClusterNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for Namespace

	// no validation rules for Annotations

	if all {
		switch v := interface{}(m.GetClusterAffinity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateFederationClusterNamespaceRequestValidationError{
					field:  "ClusterAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateFederationClusterNamespaceRequestValidationError{
					field:  "ClusterAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterAffinity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateFederationClusterNamespaceRequestValidationError{
				field:  "ClusterAffinity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return UpdateFederationClusterNamespaceRequestMultiError(errors)
	}

	return nil
}

// UpdateFederationClusterNamespaceRequestMultiError is an error wrapping
// multiple validation errors returned by
// UpdateFederationClusterNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateFederationClusterNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFederationClusterNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFederationClusterNamespaceRequestMultiError) AllErrors() []error { return m }

// UpdateFederationClusterNamespaceRequestValidationError is the validation
// error returned by UpdateFederationClusterNamespaceRequest.Validate if the
// designated constraints aren't met.
type UpdateFederationClusterNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFederationClusterNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFederationClusterNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFederationClusterNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFederationClusterNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFederationClusterNamespaceRequestValidationError) ErrorName() string {
	return "UpdateFederationClusterNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFederationClusterNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFederationClusterNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFederationClusterNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFederationClusterNamespaceRequestValidationError{}

// Validate checks the field values on UpdateFederationClusterNamespaceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *UpdateFederationClusterNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpdateFederationClusterNamespaceResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UpdateFederationClusterNamespaceResponseMultiError, or nil if none found.
func (m *UpdateFederationClusterNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFederationClusterNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateFederationClusterNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateFederationClusterNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateFederationClusterNamespaceResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return UpdateFederationClusterNamespaceResponseMultiError(errors)
	}

	return nil
}

// UpdateFederationClusterNamespaceResponseMultiError is an error wrapping
// multiple validation errors returned by
// UpdateFederationClusterNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateFederationClusterNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFederationClusterNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFederationClusterNamespaceResponseMultiError) AllErrors() []error { return m }

// UpdateFederationClusterNamespaceResponseValidationError is the validation
// error returned by UpdateFederationClusterNamespaceResponse.Validate if the
// designated constraints aren't met.
type UpdateFederationClusterNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFederationClusterNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFederationClusterNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFederationClusterNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFederationClusterNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFederationClusterNamespaceResponseValidationError) ErrorName() string {
	return "UpdateFederationClusterNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFederationClusterNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFederationClusterNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFederationClusterNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFederationClusterNamespaceResponseValidationError{}

// Validate checks the field values on DeleteFederationClusterNamespaceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *DeleteFederationClusterNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DeleteFederationClusterNamespaceRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// DeleteFederationClusterNamespaceRequestMultiError, or nil if none found.
func (m *DeleteFederationClusterNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFederationClusterNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for Namespace

	// no validation rules for Operator

	if len(errors) > 0 {
		return DeleteFederationClusterNamespaceRequestMultiError(errors)
	}

	return nil
}

// DeleteFederationClusterNamespaceRequestMultiError is an error wrapping
// multiple validation errors returned by
// DeleteFederationClusterNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteFederationClusterNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFederationClusterNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFederationClusterNamespaceRequestMultiError) AllErrors() []error { return m }

// DeleteFederationClusterNamespaceRequestValidationError is the validation
// error returned by DeleteFederationClusterNamespaceRequest.Validate if the
// designated constraints aren't met.
type DeleteFederationClusterNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFederationClusterNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFederationClusterNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFederationClusterNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFederationClusterNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFederationClusterNamespaceRequestValidationError) ErrorName() string {
	return "DeleteFederationClusterNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFederationClusterNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFederationClusterNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFederationClusterNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFederationClusterNamespaceRequestValidationError{}

// Validate checks the field values on DeleteFederationClusterNamespaceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *DeleteFederationClusterNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DeleteFederationClusterNamespaceResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// DeleteFederationClusterNamespaceResponseMultiError, or nil if none found.
func (m *DeleteFederationClusterNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFederationClusterNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteFederationClusterNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteFederationClusterNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteFederationClusterNamespaceResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return DeleteFederationClusterNamespaceResponseMultiError(errors)
	}

	return nil
}

// DeleteFederationClusterNamespaceResponseMultiError is an error wrapping
// multiple validation errors returned by
// DeleteFederationClusterNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteFederationClusterNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFederationClusterNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFederationClusterNamespaceResponseMultiError) AllErrors() []error { return m }

// DeleteFederationClusterNamespaceResponseValidationError is the validation
// error returned by DeleteFederationClusterNamespaceResponse.Validate if the
// designated constraints aren't met.
type DeleteFederationClusterNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFederationClusterNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFederationClusterNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFederationClusterNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFederationClusterNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFederationClusterNamespaceResponseValidationError) ErrorName() string {
	return "DeleteFederationClusterNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFederationClusterNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFederationClusterNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFederationClusterNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFederationClusterNamespaceResponseValidationError{}

// Validate checks the field values on FederationClusterNamespaceData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FederationClusterNamespaceData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FederationClusterNamespaceData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FederationClusterNamespaceDataMultiError, or nil if none found.
func (m *FederationClusterNamespaceData) ValidateAll() error {
	return m.validate(true)
}

func (m *FederationClusterNamespaceData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for Namespace

	// no validation rules for Annotations

	if all {
		switch v := interface{}(m.GetClusterAffinity()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FederationClusterNamespaceDataValidationError{
					field:  "ClusterAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FederationClusterNamespaceDataValidationError{
					field:  "ClusterAffinity",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetClusterAffinity()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FederationClusterNamespaceDataValidationError{
				field:  "ClusterAffinity",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for CreateTime

	// no validation rules for UpdateTime

	if m.OriginK8SData != nil {
		// no validation rules for OriginK8SData
	}

	if len(errors) > 0 {
		return FederationClusterNamespaceDataMultiError(errors)
	}

	return nil
}

// FederationClusterNamespaceDataMultiError is an error wrapping multiple
// validation errors returned by FederationClusterNamespaceData.ValidateAll()
// if the designated constraints aren't met.
type FederationClusterNamespaceDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FederationClusterNamespaceDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FederationClusterNamespaceDataMultiError) AllErrors() []error { return m }

// FederationClusterNamespaceDataValidationError is the validation error
// returned by FederationClusterNamespaceData.Validate if the designated
// constraints aren't met.
type FederationClusterNamespaceDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FederationClusterNamespaceDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FederationClusterNamespaceDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FederationClusterNamespaceDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FederationClusterNamespaceDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FederationClusterNamespaceDataValidationError) ErrorName() string {
	return "FederationClusterNamespaceDataValidationError"
}

// Error satisfies the builtin error interface
func (e FederationClusterNamespaceDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFederationClusterNamespaceData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FederationClusterNamespaceDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FederationClusterNamespaceDataValidationError{}

// Validate checks the field values on GetFederationClusterNamespaceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetFederationClusterNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFederationClusterNamespaceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetFederationClusterNamespaceRequestMultiError, or nil if none found.
func (m *GetFederationClusterNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFederationClusterNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for Namespace

	if len(errors) > 0 {
		return GetFederationClusterNamespaceRequestMultiError(errors)
	}

	return nil
}

// GetFederationClusterNamespaceRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetFederationClusterNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type GetFederationClusterNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFederationClusterNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFederationClusterNamespaceRequestMultiError) AllErrors() []error { return m }

// GetFederationClusterNamespaceRequestValidationError is the validation error
// returned by GetFederationClusterNamespaceRequest.Validate if the designated
// constraints aren't met.
type GetFederationClusterNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFederationClusterNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFederationClusterNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFederationClusterNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFederationClusterNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFederationClusterNamespaceRequestValidationError) ErrorName() string {
	return "GetFederationClusterNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFederationClusterNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFederationClusterNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFederationClusterNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFederationClusterNamespaceRequestValidationError{}

// Validate checks the field values on GetFederationClusterNamespaceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *GetFederationClusterNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFederationClusterNamespaceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetFederationClusterNamespaceResponseMultiError, or nil if none found.
func (m *GetFederationClusterNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFederationClusterNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFederationClusterNamespaceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFederationClusterNamespaceResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFederationClusterNamespaceResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFederationClusterNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFederationClusterNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFederationClusterNamespaceResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return GetFederationClusterNamespaceResponseMultiError(errors)
	}

	return nil
}

// GetFederationClusterNamespaceResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetFederationClusterNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type GetFederationClusterNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFederationClusterNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFederationClusterNamespaceResponseMultiError) AllErrors() []error { return m }

// GetFederationClusterNamespaceResponseValidationError is the validation error
// returned by GetFederationClusterNamespaceResponse.Validate if the
// designated constraints aren't met.
type GetFederationClusterNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFederationClusterNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFederationClusterNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFederationClusterNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFederationClusterNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFederationClusterNamespaceResponseValidationError) ErrorName() string {
	return "GetFederationClusterNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFederationClusterNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFederationClusterNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFederationClusterNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFederationClusterNamespaceResponseValidationError{}

// Validate checks the field values on ListFederationClusterNamespaceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListFederationClusterNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFederationClusterNamespaceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListFederationClusterNamespaceRequestMultiError, or nil if none found.
func (m *ListFederationClusterNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFederationClusterNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	if len(errors) > 0 {
		return ListFederationClusterNamespaceRequestMultiError(errors)
	}

	return nil
}

// ListFederationClusterNamespaceRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListFederationClusterNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type ListFederationClusterNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFederationClusterNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFederationClusterNamespaceRequestMultiError) AllErrors() []error { return m }

// ListFederationClusterNamespaceRequestValidationError is the validation error
// returned by ListFederationClusterNamespaceRequest.Validate if the
// designated constraints aren't met.
type ListFederationClusterNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFederationClusterNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFederationClusterNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFederationClusterNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFederationClusterNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFederationClusterNamespaceRequestValidationError) ErrorName() string {
	return "ListFederationClusterNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListFederationClusterNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFederationClusterNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFederationClusterNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFederationClusterNamespaceRequestValidationError{}

// Validate checks the field values on ListFederationClusterNamespaceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListFederationClusterNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListFederationClusterNamespaceResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListFederationClusterNamespaceResponseMultiError, or nil if none found.
func (m *ListFederationClusterNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFederationClusterNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFederationClusterNamespaceResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFederationClusterNamespaceResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFederationClusterNamespaceResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFederationClusterNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFederationClusterNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFederationClusterNamespaceResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return ListFederationClusterNamespaceResponseMultiError(errors)
	}

	return nil
}

// ListFederationClusterNamespaceResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListFederationClusterNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type ListFederationClusterNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFederationClusterNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFederationClusterNamespaceResponseMultiError) AllErrors() []error { return m }

// ListFederationClusterNamespaceResponseValidationError is the validation
// error returned by ListFederationClusterNamespaceResponse.Validate if the
// designated constraints aren't met.
type ListFederationClusterNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFederationClusterNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFederationClusterNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFederationClusterNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFederationClusterNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFederationClusterNamespaceResponseValidationError) ErrorName() string {
	return "ListFederationClusterNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListFederationClusterNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFederationClusterNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFederationClusterNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFederationClusterNamespaceResponseValidationError{}

// Validate checks the field values on
// CreateFederationClusterNamespaceQuotaRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateFederationClusterNamespaceQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateFederationClusterNamespaceQuotaRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateFederationClusterNamespaceQuotaRequestMultiError, or nil if none found.
func (m *CreateFederationClusterNamespaceQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFederationClusterNamespaceQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for Namespace

	for idx, item := range m.GetQuotaList() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateFederationClusterNamespaceQuotaRequestValidationError{
						field:  fmt.Sprintf("QuotaList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateFederationClusterNamespaceQuotaRequestValidationError{
						field:  fmt.Sprintf("QuotaList[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateFederationClusterNamespaceQuotaRequestValidationError{
					field:  fmt.Sprintf("QuotaList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return CreateFederationClusterNamespaceQuotaRequestMultiError(errors)
	}

	return nil
}

// CreateFederationClusterNamespaceQuotaRequestMultiError is an error wrapping
// multiple validation errors returned by
// CreateFederationClusterNamespaceQuotaRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateFederationClusterNamespaceQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFederationClusterNamespaceQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFederationClusterNamespaceQuotaRequestMultiError) AllErrors() []error { return m }

// CreateFederationClusterNamespaceQuotaRequestValidationError is the
// validation error returned by
// CreateFederationClusterNamespaceQuotaRequest.Validate if the designated
// constraints aren't met.
type CreateFederationClusterNamespaceQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFederationClusterNamespaceQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFederationClusterNamespaceQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateFederationClusterNamespaceQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFederationClusterNamespaceQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFederationClusterNamespaceQuotaRequestValidationError) ErrorName() string {
	return "CreateFederationClusterNamespaceQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFederationClusterNamespaceQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFederationClusterNamespaceQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFederationClusterNamespaceQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFederationClusterNamespaceQuotaRequestValidationError{}

// Validate checks the field values on
// CreateFederationClusterNamespaceQuotaResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateFederationClusterNamespaceQuotaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateFederationClusterNamespaceQuotaResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// CreateFederationClusterNamespaceQuotaResponseMultiError, or nil if none found.
func (m *CreateFederationClusterNamespaceQuotaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFederationClusterNamespaceQuotaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateFederationClusterNamespaceQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateFederationClusterNamespaceQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateFederationClusterNamespaceQuotaResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return CreateFederationClusterNamespaceQuotaResponseMultiError(errors)
	}

	return nil
}

// CreateFederationClusterNamespaceQuotaResponseMultiError is an error wrapping
// multiple validation errors returned by
// CreateFederationClusterNamespaceQuotaResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateFederationClusterNamespaceQuotaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFederationClusterNamespaceQuotaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFederationClusterNamespaceQuotaResponseMultiError) AllErrors() []error { return m }

// CreateFederationClusterNamespaceQuotaResponseValidationError is the
// validation error returned by
// CreateFederationClusterNamespaceQuotaResponse.Validate if the designated
// constraints aren't met.
type CreateFederationClusterNamespaceQuotaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFederationClusterNamespaceQuotaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFederationClusterNamespaceQuotaResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e CreateFederationClusterNamespaceQuotaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFederationClusterNamespaceQuotaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFederationClusterNamespaceQuotaResponseValidationError) ErrorName() string {
	return "CreateFederationClusterNamespaceQuotaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFederationClusterNamespaceQuotaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFederationClusterNamespaceQuotaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFederationClusterNamespaceQuotaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFederationClusterNamespaceQuotaResponseValidationError{}

// Validate checks the field values on
// UpdateFederationClusterNamespaceQuotaRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateFederationClusterNamespaceQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpdateFederationClusterNamespaceQuotaRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UpdateFederationClusterNamespaceQuotaRequestMultiError, or nil if none found.
func (m *UpdateFederationClusterNamespaceQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFederationClusterNamespaceQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for Namespace

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetQuota()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateFederationClusterNamespaceQuotaRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateFederationClusterNamespaceQuotaRequestValidationError{
					field:  "Quota",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuota()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateFederationClusterNamespaceQuotaRequestValidationError{
				field:  "Quota",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Operator

	if len(errors) > 0 {
		return UpdateFederationClusterNamespaceQuotaRequestMultiError(errors)
	}

	return nil
}

// UpdateFederationClusterNamespaceQuotaRequestMultiError is an error wrapping
// multiple validation errors returned by
// UpdateFederationClusterNamespaceQuotaRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateFederationClusterNamespaceQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFederationClusterNamespaceQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFederationClusterNamespaceQuotaRequestMultiError) AllErrors() []error { return m }

// UpdateFederationClusterNamespaceQuotaRequestValidationError is the
// validation error returned by
// UpdateFederationClusterNamespaceQuotaRequest.Validate if the designated
// constraints aren't met.
type UpdateFederationClusterNamespaceQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFederationClusterNamespaceQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFederationClusterNamespaceQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateFederationClusterNamespaceQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFederationClusterNamespaceQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFederationClusterNamespaceQuotaRequestValidationError) ErrorName() string {
	return "UpdateFederationClusterNamespaceQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFederationClusterNamespaceQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFederationClusterNamespaceQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFederationClusterNamespaceQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFederationClusterNamespaceQuotaRequestValidationError{}

// Validate checks the field values on
// UpdateFederationClusterNamespaceQuotaResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UpdateFederationClusterNamespaceQuotaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// UpdateFederationClusterNamespaceQuotaResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// UpdateFederationClusterNamespaceQuotaResponseMultiError, or nil if none found.
func (m *UpdateFederationClusterNamespaceQuotaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateFederationClusterNamespaceQuotaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateFederationClusterNamespaceQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateFederationClusterNamespaceQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateFederationClusterNamespaceQuotaResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return UpdateFederationClusterNamespaceQuotaResponseMultiError(errors)
	}

	return nil
}

// UpdateFederationClusterNamespaceQuotaResponseMultiError is an error wrapping
// multiple validation errors returned by
// UpdateFederationClusterNamespaceQuotaResponse.ValidateAll() if the
// designated constraints aren't met.
type UpdateFederationClusterNamespaceQuotaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateFederationClusterNamespaceQuotaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateFederationClusterNamespaceQuotaResponseMultiError) AllErrors() []error { return m }

// UpdateFederationClusterNamespaceQuotaResponseValidationError is the
// validation error returned by
// UpdateFederationClusterNamespaceQuotaResponse.Validate if the designated
// constraints aren't met.
type UpdateFederationClusterNamespaceQuotaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateFederationClusterNamespaceQuotaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateFederationClusterNamespaceQuotaResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e UpdateFederationClusterNamespaceQuotaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateFederationClusterNamespaceQuotaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateFederationClusterNamespaceQuotaResponseValidationError) ErrorName() string {
	return "UpdateFederationClusterNamespaceQuotaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateFederationClusterNamespaceQuotaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateFederationClusterNamespaceQuotaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateFederationClusterNamespaceQuotaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateFederationClusterNamespaceQuotaResponseValidationError{}

// Validate checks the field values on
// DeleteFederationClusterNamespaceQuotaRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteFederationClusterNamespaceQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DeleteFederationClusterNamespaceQuotaRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// DeleteFederationClusterNamespaceQuotaRequestMultiError, or nil if none found.
func (m *DeleteFederationClusterNamespaceQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFederationClusterNamespaceQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for Namespace

	// no validation rules for Name

	if len(errors) > 0 {
		return DeleteFederationClusterNamespaceQuotaRequestMultiError(errors)
	}

	return nil
}

// DeleteFederationClusterNamespaceQuotaRequestMultiError is an error wrapping
// multiple validation errors returned by
// DeleteFederationClusterNamespaceQuotaRequest.ValidateAll() if the
// designated constraints aren't met.
type DeleteFederationClusterNamespaceQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFederationClusterNamespaceQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFederationClusterNamespaceQuotaRequestMultiError) AllErrors() []error { return m }

// DeleteFederationClusterNamespaceQuotaRequestValidationError is the
// validation error returned by
// DeleteFederationClusterNamespaceQuotaRequest.Validate if the designated
// constraints aren't met.
type DeleteFederationClusterNamespaceQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFederationClusterNamespaceQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFederationClusterNamespaceQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFederationClusterNamespaceQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFederationClusterNamespaceQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFederationClusterNamespaceQuotaRequestValidationError) ErrorName() string {
	return "DeleteFederationClusterNamespaceQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFederationClusterNamespaceQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFederationClusterNamespaceQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFederationClusterNamespaceQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFederationClusterNamespaceQuotaRequestValidationError{}

// Validate checks the field values on
// DeleteFederationClusterNamespaceQuotaResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteFederationClusterNamespaceQuotaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// DeleteFederationClusterNamespaceQuotaResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// DeleteFederationClusterNamespaceQuotaResponseMultiError, or nil if none found.
func (m *DeleteFederationClusterNamespaceQuotaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFederationClusterNamespaceQuotaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteFederationClusterNamespaceQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteFederationClusterNamespaceQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteFederationClusterNamespaceQuotaResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return DeleteFederationClusterNamespaceQuotaResponseMultiError(errors)
	}

	return nil
}

// DeleteFederationClusterNamespaceQuotaResponseMultiError is an error wrapping
// multiple validation errors returned by
// DeleteFederationClusterNamespaceQuotaResponse.ValidateAll() if the
// designated constraints aren't met.
type DeleteFederationClusterNamespaceQuotaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFederationClusterNamespaceQuotaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFederationClusterNamespaceQuotaResponseMultiError) AllErrors() []error { return m }

// DeleteFederationClusterNamespaceQuotaResponseValidationError is the
// validation error returned by
// DeleteFederationClusterNamespaceQuotaResponse.Validate if the designated
// constraints aren't met.
type DeleteFederationClusterNamespaceQuotaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFederationClusterNamespaceQuotaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFederationClusterNamespaceQuotaResponseValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e DeleteFederationClusterNamespaceQuotaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFederationClusterNamespaceQuotaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFederationClusterNamespaceQuotaResponseValidationError) ErrorName() string {
	return "DeleteFederationClusterNamespaceQuotaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteFederationClusterNamespaceQuotaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFederationClusterNamespaceQuotaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFederationClusterNamespaceQuotaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFederationClusterNamespaceQuotaResponseValidationError{}

// Validate checks the field values on
// GetFederationClusterNamespaceQuotaRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetFederationClusterNamespaceQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetFederationClusterNamespaceQuotaRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetFederationClusterNamespaceQuotaRequestMultiError, or nil if none found.
func (m *GetFederationClusterNamespaceQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFederationClusterNamespaceQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for Namespace

	// no validation rules for Name

	if len(errors) > 0 {
		return GetFederationClusterNamespaceQuotaRequestMultiError(errors)
	}

	return nil
}

// GetFederationClusterNamespaceQuotaRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetFederationClusterNamespaceQuotaRequest.ValidateAll() if the designated
// constraints aren't met.
type GetFederationClusterNamespaceQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFederationClusterNamespaceQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFederationClusterNamespaceQuotaRequestMultiError) AllErrors() []error { return m }

// GetFederationClusterNamespaceQuotaRequestValidationError is the validation
// error returned by GetFederationClusterNamespaceQuotaRequest.Validate if the
// designated constraints aren't met.
type GetFederationClusterNamespaceQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFederationClusterNamespaceQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFederationClusterNamespaceQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFederationClusterNamespaceQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFederationClusterNamespaceQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFederationClusterNamespaceQuotaRequestValidationError) ErrorName() string {
	return "GetFederationClusterNamespaceQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFederationClusterNamespaceQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFederationClusterNamespaceQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFederationClusterNamespaceQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFederationClusterNamespaceQuotaRequestValidationError{}

// Validate checks the field values on
// GetFederationClusterNamespaceQuotaResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetFederationClusterNamespaceQuotaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// GetFederationClusterNamespaceQuotaResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// GetFederationClusterNamespaceQuotaResponseMultiError, or nil if none found.
func (m *GetFederationClusterNamespaceQuotaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFederationClusterNamespaceQuotaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFederationClusterNamespaceQuotaResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFederationClusterNamespaceQuotaResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFederationClusterNamespaceQuotaResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFederationClusterNamespaceQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFederationClusterNamespaceQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFederationClusterNamespaceQuotaResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return GetFederationClusterNamespaceQuotaResponseMultiError(errors)
	}

	return nil
}

// GetFederationClusterNamespaceQuotaResponseMultiError is an error wrapping
// multiple validation errors returned by
// GetFederationClusterNamespaceQuotaResponse.ValidateAll() if the designated
// constraints aren't met.
type GetFederationClusterNamespaceQuotaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFederationClusterNamespaceQuotaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFederationClusterNamespaceQuotaResponseMultiError) AllErrors() []error { return m }

// GetFederationClusterNamespaceQuotaResponseValidationError is the validation
// error returned by GetFederationClusterNamespaceQuotaResponse.Validate if
// the designated constraints aren't met.
type GetFederationClusterNamespaceQuotaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFederationClusterNamespaceQuotaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFederationClusterNamespaceQuotaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFederationClusterNamespaceQuotaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFederationClusterNamespaceQuotaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFederationClusterNamespaceQuotaResponseValidationError) ErrorName() string {
	return "GetFederationClusterNamespaceQuotaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFederationClusterNamespaceQuotaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFederationClusterNamespaceQuotaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFederationClusterNamespaceQuotaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFederationClusterNamespaceQuotaResponseValidationError{}

// Validate checks the field values on
// ListFederationClusterNamespaceQuotaRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListFederationClusterNamespaceQuotaRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListFederationClusterNamespaceQuotaRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListFederationClusterNamespaceQuotaRequestMultiError, or nil if none found.
func (m *ListFederationClusterNamespaceQuotaRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFederationClusterNamespaceQuotaRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterId

	// no validation rules for Namespace

	if len(errors) > 0 {
		return ListFederationClusterNamespaceQuotaRequestMultiError(errors)
	}

	return nil
}

// ListFederationClusterNamespaceQuotaRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListFederationClusterNamespaceQuotaRequest.ValidateAll() if the designated
// constraints aren't met.
type ListFederationClusterNamespaceQuotaRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFederationClusterNamespaceQuotaRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFederationClusterNamespaceQuotaRequestMultiError) AllErrors() []error { return m }

// ListFederationClusterNamespaceQuotaRequestValidationError is the validation
// error returned by ListFederationClusterNamespaceQuotaRequest.Validate if
// the designated constraints aren't met.
type ListFederationClusterNamespaceQuotaRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFederationClusterNamespaceQuotaRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFederationClusterNamespaceQuotaRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFederationClusterNamespaceQuotaRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFederationClusterNamespaceQuotaRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFederationClusterNamespaceQuotaRequestValidationError) ErrorName() string {
	return "ListFederationClusterNamespaceQuotaRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListFederationClusterNamespaceQuotaRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFederationClusterNamespaceQuotaRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFederationClusterNamespaceQuotaRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFederationClusterNamespaceQuotaRequestValidationError{}

// Validate checks the field values on
// ListFederationClusterNamespaceQuotaResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListFederationClusterNamespaceQuotaResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListFederationClusterNamespaceQuotaResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListFederationClusterNamespaceQuotaResponseMultiError, or nil if none found.
func (m *ListFederationClusterNamespaceQuotaResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFederationClusterNamespaceQuotaResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFederationClusterNamespaceQuotaResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFederationClusterNamespaceQuotaResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFederationClusterNamespaceQuotaResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFederationClusterNamespaceQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFederationClusterNamespaceQuotaResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFederationClusterNamespaceQuotaResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return ListFederationClusterNamespaceQuotaResponseMultiError(errors)
	}

	return nil
}

// ListFederationClusterNamespaceQuotaResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListFederationClusterNamespaceQuotaResponse.ValidateAll() if the designated
// constraints aren't met.
type ListFederationClusterNamespaceQuotaResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFederationClusterNamespaceQuotaResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFederationClusterNamespaceQuotaResponseMultiError) AllErrors() []error { return m }

// ListFederationClusterNamespaceQuotaResponseValidationError is the validation
// error returned by ListFederationClusterNamespaceQuotaResponse.Validate if
// the designated constraints aren't met.
type ListFederationClusterNamespaceQuotaResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFederationClusterNamespaceQuotaResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFederationClusterNamespaceQuotaResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFederationClusterNamespaceQuotaResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFederationClusterNamespaceQuotaResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFederationClusterNamespaceQuotaResponseValidationError) ErrorName() string {
	return "ListFederationClusterNamespaceQuotaResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListFederationClusterNamespaceQuotaResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFederationClusterNamespaceQuotaResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFederationClusterNamespaceQuotaResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFederationClusterNamespaceQuotaResponseValidationError{}

// Validate checks the field values on WebAnnotations with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WebAnnotations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebAnnotations with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WebAnnotationsMultiError,
// or nil if none found.
func (m *WebAnnotations) ValidateAll() error {
	return m.validate(true)
}

func (m *WebAnnotations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPerms()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WebAnnotationsValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WebAnnotationsValidationError{
					field:  "Perms",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPerms()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WebAnnotationsValidationError{
				field:  "Perms",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WebAnnotationsMultiError(errors)
	}

	return nil
}

// WebAnnotationsMultiError is an error wrapping multiple validation errors
// returned by WebAnnotations.ValidateAll() if the designated constraints
// aren't met.
type WebAnnotationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebAnnotationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebAnnotationsMultiError) AllErrors() []error { return m }

// WebAnnotationsValidationError is the validation error returned by
// WebAnnotations.Validate if the designated constraints aren't met.
type WebAnnotationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebAnnotationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebAnnotationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebAnnotationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebAnnotationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebAnnotationsValidationError) ErrorName() string { return "WebAnnotationsValidationError" }

// Error satisfies the builtin error interface
func (e WebAnnotationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebAnnotations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebAnnotationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebAnnotationsValidationError{}

// Validate checks the field values on
// ListFederationClusterWithSubclusterRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListFederationClusterWithSubclusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListFederationClusterWithSubclusterRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListFederationClusterWithSubclusterRequestMultiError, or nil if none found.
func (m *ListFederationClusterWithSubclusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFederationClusterWithSubclusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Conditions

	// no validation rules for SubConditions

	if len(errors) > 0 {
		return ListFederationClusterWithSubclusterRequestMultiError(errors)
	}

	return nil
}

// ListFederationClusterWithSubclusterRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListFederationClusterWithSubclusterRequest.ValidateAll() if the designated
// constraints aren't met.
type ListFederationClusterWithSubclusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFederationClusterWithSubclusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFederationClusterWithSubclusterRequestMultiError) AllErrors() []error { return m }

// ListFederationClusterWithSubclusterRequestValidationError is the validation
// error returned by ListFederationClusterWithSubclusterRequest.Validate if
// the designated constraints aren't met.
type ListFederationClusterWithSubclusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFederationClusterWithSubclusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFederationClusterWithSubclusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFederationClusterWithSubclusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFederationClusterWithSubclusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFederationClusterWithSubclusterRequestValidationError) ErrorName() string {
	return "ListFederationClusterWithSubclusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListFederationClusterWithSubclusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFederationClusterWithSubclusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFederationClusterWithSubclusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFederationClusterWithSubclusterRequestValidationError{}

// Validate checks the field values on
// ListFederationClusterWithSubclusterResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListFederationClusterWithSubclusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListFederationClusterWithSubclusterResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListFederationClusterWithSubclusterResponseMultiError, or nil if none found.
func (m *ListFederationClusterWithSubclusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFederationClusterWithSubclusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFederationClusterWithSubclusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFederationClusterWithSubclusterResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFederationClusterWithSubclusterResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFederationClusterWithSubclusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFederationClusterWithSubclusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFederationClusterWithSubclusterResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return ListFederationClusterWithSubclusterResponseMultiError(errors)
	}

	return nil
}

// ListFederationClusterWithSubclusterResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListFederationClusterWithSubclusterResponse.ValidateAll() if the designated
// constraints aren't met.
type ListFederationClusterWithSubclusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFederationClusterWithSubclusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFederationClusterWithSubclusterResponseMultiError) AllErrors() []error { return m }

// ListFederationClusterWithSubclusterResponseValidationError is the validation
// error returned by ListFederationClusterWithSubclusterResponse.Validate if
// the designated constraints aren't met.
type ListFederationClusterWithSubclusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFederationClusterWithSubclusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFederationClusterWithSubclusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFederationClusterWithSubclusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFederationClusterWithSubclusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFederationClusterWithSubclusterResponseValidationError) ErrorName() string {
	return "ListFederationClusterWithSubclusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListFederationClusterWithSubclusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFederationClusterWithSubclusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFederationClusterWithSubclusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFederationClusterWithSubclusterResponseValidationError{}

// Validate checks the field values on FederationClusterWithSubcluster with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FederationClusterWithSubcluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FederationClusterWithSubcluster with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FederationClusterWithSubclusterMultiError, or nil if none found.
func (m *FederationClusterWithSubcluster) ValidateAll() error {
	return m.validate(true)
}

func (m *FederationClusterWithSubcluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ProjectId

	// no validation rules for FederationClusterId

	// no validation rules for FederationClusterName

	// no validation rules for HostClusterId

	// no validation rules for CreatedTime

	// no validation rules for UpdatedTime

	for idx, item := range m.GetSubClusters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FederationClusterWithSubclusterValidationError{
						field:  fmt.Sprintf("SubClusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FederationClusterWithSubclusterValidationError{
						field:  fmt.Sprintf("SubClusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FederationClusterWithSubclusterValidationError{
					field:  fmt.Sprintf("SubClusters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FederationClusterWithSubclusterMultiError(errors)
	}

	return nil
}

// FederationClusterWithSubclusterMultiError is an error wrapping multiple
// validation errors returned by FederationClusterWithSubcluster.ValidateAll()
// if the designated constraints aren't met.
type FederationClusterWithSubclusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FederationClusterWithSubclusterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FederationClusterWithSubclusterMultiError) AllErrors() []error { return m }

// FederationClusterWithSubclusterValidationError is the validation error
// returned by FederationClusterWithSubcluster.Validate if the designated
// constraints aren't met.
type FederationClusterWithSubclusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FederationClusterWithSubclusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FederationClusterWithSubclusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FederationClusterWithSubclusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FederationClusterWithSubclusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FederationClusterWithSubclusterValidationError) ErrorName() string {
	return "FederationClusterWithSubclusterValidationError"
}

// Error satisfies the builtin error interface
func (e FederationClusterWithSubclusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFederationClusterWithSubcluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FederationClusterWithSubclusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FederationClusterWithSubclusterValidationError{}

// Validate checks the field values on FederationSubCluster with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FederationSubCluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FederationSubCluster with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FederationSubClusterMultiError, or nil if none found.
func (m *FederationSubCluster) ValidateAll() error {
	return m.validate(true)
}

func (m *FederationSubCluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ProjectId

	// no validation rules for SubClusterId

	// no validation rules for SubClusterName

	// no validation rules for FederationClusterId

	// no validation rules for HostClusterId

	// no validation rules for ClusternetClusterName

	// no validation rules for ClusternetClusterNamespace

	// no validation rules for CreatedTime

	// no validation rules for UpdatedTime

	// no validation rules for Status

	// no validation rules for Labels

	if len(errors) > 0 {
		return FederationSubClusterMultiError(errors)
	}

	return nil
}

// FederationSubClusterMultiError is an error wrapping multiple validation
// errors returned by FederationSubCluster.ValidateAll() if the designated
// constraints aren't met.
type FederationSubClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FederationSubClusterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FederationSubClusterMultiError) AllErrors() []error { return m }

// FederationSubClusterValidationError is the validation error returned by
// FederationSubCluster.Validate if the designated constraints aren't met.
type FederationSubClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FederationSubClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FederationSubClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FederationSubClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FederationSubClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FederationSubClusterValidationError) ErrorName() string {
	return "FederationSubClusterValidationError"
}

// Error satisfies the builtin error interface
func (e FederationSubClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFederationSubCluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FederationSubClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FederationSubClusterValidationError{}

// Validate checks the field values on
// ListFederationClusterWithNamespaceRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListFederationClusterWithNamespaceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListFederationClusterWithNamespaceRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListFederationClusterWithNamespaceRequestMultiError, or nil if none found.
func (m *ListFederationClusterWithNamespaceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFederationClusterWithNamespaceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Conditions

	// no validation rules for SubConditions

	if len(errors) > 0 {
		return ListFederationClusterWithNamespaceRequestMultiError(errors)
	}

	return nil
}

// ListFederationClusterWithNamespaceRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListFederationClusterWithNamespaceRequest.ValidateAll() if the designated
// constraints aren't met.
type ListFederationClusterWithNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFederationClusterWithNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFederationClusterWithNamespaceRequestMultiError) AllErrors() []error { return m }

// ListFederationClusterWithNamespaceRequestValidationError is the validation
// error returned by ListFederationClusterWithNamespaceRequest.Validate if the
// designated constraints aren't met.
type ListFederationClusterWithNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFederationClusterWithNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFederationClusterWithNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFederationClusterWithNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFederationClusterWithNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFederationClusterWithNamespaceRequestValidationError) ErrorName() string {
	return "ListFederationClusterWithNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListFederationClusterWithNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFederationClusterWithNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFederationClusterWithNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFederationClusterWithNamespaceRequestValidationError{}

// Validate checks the field values on
// ListFederationClusterWithNamespaceResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListFederationClusterWithNamespaceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListFederationClusterWithNamespaceResponse with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ListFederationClusterWithNamespaceResponseMultiError, or nil if none found.
func (m *ListFederationClusterWithNamespaceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFederationClusterWithNamespaceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListFederationClusterWithNamespaceResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListFederationClusterWithNamespaceResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListFederationClusterWithNamespaceResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFederationClusterWithNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFederationClusterWithNamespaceResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFederationClusterWithNamespaceResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return ListFederationClusterWithNamespaceResponseMultiError(errors)
	}

	return nil
}

// ListFederationClusterWithNamespaceResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListFederationClusterWithNamespaceResponse.ValidateAll() if the designated
// constraints aren't met.
type ListFederationClusterWithNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFederationClusterWithNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFederationClusterWithNamespaceResponseMultiError) AllErrors() []error { return m }

// ListFederationClusterWithNamespaceResponseValidationError is the validation
// error returned by ListFederationClusterWithNamespaceResponse.Validate if
// the designated constraints aren't met.
type ListFederationClusterWithNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFederationClusterWithNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFederationClusterWithNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFederationClusterWithNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFederationClusterWithNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFederationClusterWithNamespaceResponseValidationError) ErrorName() string {
	return "ListFederationClusterWithNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListFederationClusterWithNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFederationClusterWithNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFederationClusterWithNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFederationClusterWithNamespaceResponseValidationError{}

// Validate checks the field values on FederationClusterWithNamespace with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FederationClusterWithNamespace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FederationClusterWithNamespace with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FederationClusterWithNamespaceMultiError, or nil if none found.
func (m *FederationClusterWithNamespace) ValidateAll() error {
	return m.validate(true)
}

func (m *FederationClusterWithNamespace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FederationClusterId

	// no validation rules for FederationClusterName

	// no validation rules for HostClusterId

	// no validation rules for ProjectCode

	// no validation rules for ProjectId

	// no validation rules for CreatedTime

	// no validation rules for UpdatedTime

	for idx, item := range m.GetFederationNamespaces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FederationClusterWithNamespaceValidationError{
						field:  fmt.Sprintf("FederationNamespaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FederationClusterWithNamespaceValidationError{
						field:  fmt.Sprintf("FederationNamespaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FederationClusterWithNamespaceValidationError{
					field:  fmt.Sprintf("FederationNamespaces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FederationClusterWithNamespaceMultiError(errors)
	}

	return nil
}

// FederationClusterWithNamespaceMultiError is an error wrapping multiple
// validation errors returned by FederationClusterWithNamespace.ValidateAll()
// if the designated constraints aren't met.
type FederationClusterWithNamespaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FederationClusterWithNamespaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FederationClusterWithNamespaceMultiError) AllErrors() []error { return m }

// FederationClusterWithNamespaceValidationError is the validation error
// returned by FederationClusterWithNamespace.Validate if the designated
// constraints aren't met.
type FederationClusterWithNamespaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FederationClusterWithNamespaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FederationClusterWithNamespaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FederationClusterWithNamespaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FederationClusterWithNamespaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FederationClusterWithNamespaceValidationError) ErrorName() string {
	return "FederationClusterWithNamespaceValidationError"
}

// Error satisfies the builtin error interface
func (e FederationClusterWithNamespaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFederationClusterWithNamespace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FederationClusterWithNamespaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FederationClusterWithNamespaceValidationError{}

// Validate checks the field values on FederationNamespace with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FederationNamespace) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FederationNamespace with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FederationNamespaceMultiError, or nil if none found.
func (m *FederationNamespace) ValidateAll() error {
	return m.validate(true)
}

func (m *FederationNamespace) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectCode

	// no validation rules for ProjectId

	// no validation rules for FederationNamespace

	// no validation rules for FederationClusterId

	// no validation rules for HostClusterId

	// no validation rules for CreatedTime

	if len(errors) > 0 {
		return FederationNamespaceMultiError(errors)
	}

	return nil
}

// FederationNamespaceMultiError is an error wrapping multiple validation
// errors returned by FederationNamespace.ValidateAll() if the designated
// constraints aren't met.
type FederationNamespaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FederationNamespaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FederationNamespaceMultiError) AllErrors() []error { return m }

// FederationNamespaceValidationError is the validation error returned by
// FederationNamespace.Validate if the designated constraints aren't met.
type FederationNamespaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FederationNamespaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FederationNamespaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FederationNamespaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FederationNamespaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FederationNamespaceValidationError) ErrorName() string {
	return "FederationNamespaceValidationError"
}

// Error satisfies the builtin error interface
func (e FederationNamespaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFederationNamespace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FederationNamespaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FederationNamespaceValidationError{}

// Validate checks the field values on GetTaskRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetTaskRequestMultiError,
// or nil if none found.
func (m *GetTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	if len(errors) > 0 {
		return GetTaskRequestMultiError(errors)
	}

	return nil
}

// GetTaskRequestMultiError is an error wrapping multiple validation errors
// returned by GetTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type GetTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskRequestMultiError) AllErrors() []error { return m }

// GetTaskRequestValidationError is the validation error returned by
// GetTaskRequest.Validate if the designated constraints aren't met.
type GetTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskRequestValidationError) ErrorName() string { return "GetTaskRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskRequestValidationError{}

// Validate checks the field values on GetTaskResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTaskResponseMultiError, or nil if none found.
func (m *GetTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return GetTaskResponseMultiError(errors)
	}

	return nil
}

// GetTaskResponseMultiError is an error wrapping multiple validation errors
// returned by GetTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type GetTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskResponseMultiError) AllErrors() []error { return m }

// GetTaskResponseValidationError is the validation error returned by
// GetTaskResponse.Validate if the designated constraints aren't met.
type GetTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskResponseValidationError) ErrorName() string { return "GetTaskResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskResponseValidationError{}

// Validate checks the field values on ListTasksRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListTasksRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTasksRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTasksRequestMultiError, or nil if none found.
func (m *ListTasksRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTasksRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTaskType()) < 1 {
		err := ListTasksRequestValidationError{
			field:  "TaskType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetTaskIndex()) < 1 {
		err := ListTasksRequestValidationError{
			field:  "TaskIndex",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Offset

	// no validation rules for Limit

	if len(errors) > 0 {
		return ListTasksRequestMultiError(errors)
	}

	return nil
}

// ListTasksRequestMultiError is an error wrapping multiple validation errors
// returned by ListTasksRequest.ValidateAll() if the designated constraints
// aren't met.
type ListTasksRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTasksRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTasksRequestMultiError) AllErrors() []error { return m }

// ListTasksRequestValidationError is the validation error returned by
// ListTasksRequest.Validate if the designated constraints aren't met.
type ListTasksRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTasksRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTasksRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTasksRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTasksRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTasksRequestValidationError) ErrorName() string { return "ListTasksRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListTasksRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTasksRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTasksRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTasksRequestValidationError{}

// Validate checks the field values on ListTasksResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListTasksResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTasksResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTasksResponseMultiError, or nil if none found.
func (m *ListTasksResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTasksResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTasksResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTasksResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTasksResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListTasksResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListTasksResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListTasksResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return ListTasksResponseMultiError(errors)
	}

	return nil
}

// ListTasksResponseMultiError is an error wrapping multiple validation errors
// returned by ListTasksResponse.ValidateAll() if the designated constraints
// aren't met.
type ListTasksResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTasksResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTasksResponseMultiError) AllErrors() []error { return m }

// ListTasksResponseValidationError is the validation error returned by
// ListTasksResponse.Validate if the designated constraints aren't met.
type ListTasksResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTasksResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTasksResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTasksResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTasksResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTasksResponseValidationError) ErrorName() string {
	return "ListTasksResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTasksResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTasksResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTasksResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTasksResponseValidationError{}

// Validate checks the field values on RetryTaskRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RetryTaskRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryTaskRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetryTaskRequestMultiError, or nil if none found.
func (m *RetryTaskRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryTaskRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	// no validation rules for BeginStepName

	if len(errors) > 0 {
		return RetryTaskRequestMultiError(errors)
	}

	return nil
}

// RetryTaskRequestMultiError is an error wrapping multiple validation errors
// returned by RetryTaskRequest.ValidateAll() if the designated constraints
// aren't met.
type RetryTaskRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryTaskRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryTaskRequestMultiError) AllErrors() []error { return m }

// RetryTaskRequestValidationError is the validation error returned by
// RetryTaskRequest.Validate if the designated constraints aren't met.
type RetryTaskRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryTaskRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryTaskRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryTaskRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryTaskRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryTaskRequestValidationError) ErrorName() string { return "RetryTaskRequestValidationError" }

// Error satisfies the builtin error interface
func (e RetryTaskRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryTaskRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryTaskRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryTaskRequestValidationError{}

// Validate checks the field values on RetryTaskResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RetryTaskResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RetryTaskResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RetryTaskResponseMultiError, or nil if none found.
func (m *RetryTaskResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RetryTaskResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetryTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetryTaskResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetryTaskResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RetryTaskResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RetryTaskResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RetryTaskResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return RetryTaskResponseMultiError(errors)
	}

	return nil
}

// RetryTaskResponseMultiError is an error wrapping multiple validation errors
// returned by RetryTaskResponse.ValidateAll() if the designated constraints
// aren't met.
type RetryTaskResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RetryTaskResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RetryTaskResponseMultiError) AllErrors() []error { return m }

// RetryTaskResponseValidationError is the validation error returned by
// RetryTaskResponse.Validate if the designated constraints aren't met.
type RetryTaskResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RetryTaskResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RetryTaskResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RetryTaskResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RetryTaskResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RetryTaskResponseValidationError) ErrorName() string {
	return "RetryTaskResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RetryTaskResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRetryTaskResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RetryTaskResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RetryTaskResponseValidationError{}

// Validate checks the field values on Task with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Task) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Task with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TaskMultiError, or nil if none found.
func (m *Task) ValidateAll() error {
	return m.validate(true)
}

func (m *Task) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskIndex

	// no validation rules for TaskId

	// no validation rules for TaskType

	// no validation rules for TaskName

	// no validation rules for CurrentStep

	{
		sorted_keys := make([]string, len(m.GetSteps()))
		i := 0
		for key := range m.GetSteps() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSteps()[key]
			_ = val

			// no validation rules for Steps[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TaskValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TaskValidationError{
							field:  fmt.Sprintf("Steps[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TaskValidationError{
						field:  fmt.Sprintf("Steps[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for CallBackFuncName

	// no validation rules for CommonParams

	// no validation rules for ExtraJson

	// no validation rules for Status

	// no validation rules for Message

	// no validation rules for ForceTerminate

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ExecutionTime

	// no validation rules for MaxExecutionSeconds

	// no validation rules for Creator

	// no validation rules for LastUpdate

	// no validation rules for Updater

	if len(errors) > 0 {
		return TaskMultiError(errors)
	}

	return nil
}

// TaskMultiError is an error wrapping multiple validation errors returned by
// Task.ValidateAll() if the designated constraints aren't met.
type TaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskMultiError) AllErrors() []error { return m }

// TaskValidationError is the validation error returned by Task.Validate if the
// designated constraints aren't met.
type TaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskValidationError) ErrorName() string { return "TaskValidationError" }

// Error satisfies the builtin error interface
func (e TaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskValidationError{}

// Validate checks the field values on Step with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Step) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Step with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StepMultiError, or nil if none found.
func (m *Step) ValidateAll() error {
	return m.validate(true)
}

func (m *Step) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Alias

	// no validation rules for Params

	// no validation rules for Extras

	// no validation rules for Status

	// no validation rules for Message

	// no validation rules for SkipOnFailed

	// no validation rules for RetryCount

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for ExecutionTime

	// no validation rules for MaxExecutionSeconds

	// no validation rules for LastUpdate

	if len(errors) > 0 {
		return StepMultiError(errors)
	}

	return nil
}

// StepMultiError is an error wrapping multiple validation errors returned by
// Step.ValidateAll() if the designated constraints aren't met.
type StepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StepMultiError) AllErrors() []error { return m }

// StepValidationError is the validation error returned by Step.Validate if the
// designated constraints aren't met.
type StepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StepValidationError) ErrorName() string { return "StepValidationError" }

// Error satisfies the builtin error interface
func (e StepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStep.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StepValidationError{}

// Validate checks the field values on GetTaskRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTaskRecordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskRecordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTaskRecordRequestMultiError, or nil if none found.
func (m *GetTaskRecordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskRecordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	if len(errors) > 0 {
		return GetTaskRecordRequestMultiError(errors)
	}

	return nil
}

// GetTaskRecordRequestMultiError is an error wrapping multiple validation
// errors returned by GetTaskRecordRequest.ValidateAll() if the designated
// constraints aren't met.
type GetTaskRecordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskRecordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskRecordRequestMultiError) AllErrors() []error { return m }

// GetTaskRecordRequestValidationError is the validation error returned by
// GetTaskRecordRequest.Validate if the designated constraints aren't met.
type GetTaskRecordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskRecordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskRecordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskRecordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskRecordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskRecordRequestValidationError) ErrorName() string {
	return "GetTaskRecordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTaskRecordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskRecordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskRecordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskRecordRequestValidationError{}

// Validate checks the field values on GetTaskRecordResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetTaskRecordResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetTaskRecordResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetTaskRecordResponseMultiError, or nil if none found.
func (m *GetTaskRecordResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetTaskRecordResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskRecordResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskRecordResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskRecordResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetTaskRecordResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetTaskRecordResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetTaskRecordResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return GetTaskRecordResponseMultiError(errors)
	}

	return nil
}

// GetTaskRecordResponseMultiError is an error wrapping multiple validation
// errors returned by GetTaskRecordResponse.ValidateAll() if the designated
// constraints aren't met.
type GetTaskRecordResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTaskRecordResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTaskRecordResponseMultiError) AllErrors() []error { return m }

// GetTaskRecordResponseValidationError is the validation error returned by
// GetTaskRecordResponse.Validate if the designated constraints aren't met.
type GetTaskRecordResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTaskRecordResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTaskRecordResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTaskRecordResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTaskRecordResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTaskRecordResponseValidationError) ErrorName() string {
	return "GetTaskRecordResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetTaskRecordResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTaskRecordResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTaskRecordResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTaskRecordResponseValidationError{}

// Validate checks the field values on TaskRecord with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaskRecord) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskRecord with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaskRecordMultiError, or
// nil if none found.
func (m *TaskRecord) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskRecord) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	for idx, item := range m.GetStep() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskRecordValidationError{
						field:  fmt.Sprintf("Step[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskRecordValidationError{
						field:  fmt.Sprintf("Step[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskRecordValidationError{
					field:  fmt.Sprintf("Step[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TaskRecordMultiError(errors)
	}

	return nil
}

// TaskRecordMultiError is an error wrapping multiple validation errors
// returned by TaskRecord.ValidateAll() if the designated constraints aren't met.
type TaskRecordMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskRecordMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskRecordMultiError) AllErrors() []error { return m }

// TaskRecordValidationError is the validation error returned by
// TaskRecord.Validate if the designated constraints aren't met.
type TaskRecordValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskRecordValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskRecordValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskRecordValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskRecordValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskRecordValidationError) ErrorName() string { return "TaskRecordValidationError" }

// Error satisfies the builtin error interface
func (e TaskRecordValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskRecord.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskRecordValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskRecordValidationError{}

// Validate checks the field values on TaskRecordStep with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaskRecordStep) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskRecordStep with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaskRecordStepMultiError,
// or nil if none found.
func (m *TaskRecordStep) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskRecordStep) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Status

	// no validation rules for StartTime

	// no validation rules for EndTime

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TaskRecordStepValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TaskRecordStepValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TaskRecordStepValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetAllowSkip()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskRecordStepValidationError{
					field:  "AllowSkip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskRecordStepValidationError{
					field:  "AllowSkip",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAllowSkip()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskRecordStepValidationError{
				field:  "AllowSkip",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAllowRetry()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskRecordStepValidationError{
					field:  "AllowRetry",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskRecordStepValidationError{
					field:  "AllowRetry",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAllowRetry()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskRecordStepValidationError{
				field:  "AllowRetry",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TaskRecordStepMultiError(errors)
	}

	return nil
}

// TaskRecordStepMultiError is an error wrapping multiple validation errors
// returned by TaskRecordStep.ValidateAll() if the designated constraints
// aren't met.
type TaskRecordStepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskRecordStepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskRecordStepMultiError) AllErrors() []error { return m }

// TaskRecordStepValidationError is the validation error returned by
// TaskRecordStep.Validate if the designated constraints aren't met.
type TaskRecordStepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskRecordStepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskRecordStepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskRecordStepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskRecordStepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskRecordStepValidationError) ErrorName() string { return "TaskRecordStepValidationError" }

// Error satisfies the builtin error interface
func (e TaskRecordStepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskRecordStep.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskRecordStepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskRecordStepValidationError{}

// Validate checks the field values on TaskRecordStepData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TaskRecordStepData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskRecordStepData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskRecordStepDataMultiError, or nil if none found.
func (m *TaskRecordStepData) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskRecordStepData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Log

	// no validation rules for Timestamp

	// no validation rules for Level

	if len(errors) > 0 {
		return TaskRecordStepDataMultiError(errors)
	}

	return nil
}

// TaskRecordStepDataMultiError is an error wrapping multiple validation errors
// returned by TaskRecordStepData.ValidateAll() if the designated constraints
// aren't met.
type TaskRecordStepDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskRecordStepDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskRecordStepDataMultiError) AllErrors() []error { return m }

// TaskRecordStepDataValidationError is the validation error returned by
// TaskRecordStepData.Validate if the designated constraints aren't met.
type TaskRecordStepDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskRecordStepDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskRecordStepDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskRecordStepDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskRecordStepDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskRecordStepDataValidationError) ErrorName() string {
	return "TaskRecordStepDataValidationError"
}

// Error satisfies the builtin error interface
func (e TaskRecordStepDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskRecordStepData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskRecordStepDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskRecordStepDataValidationError{}

// Validate checks the field values on InstallFederationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstallFederationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallFederationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallFederationRequestMultiError, or nil if none found.
func (m *InstallFederationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallFederationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 1 || l > 100 {
		err := InstallFederationRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 1 || l > 100 {
		err := InstallFederationRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for UserToken

	// no validation rules for LoadBalancerId

	if l := utf8.RuneCountInString(m.GetFederationProjectId()); l < 1 || l > 100 {
		err := InstallFederationRequestValidationError{
			field:  "FederationProjectId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetFederationProjectCode()); l < 1 || l > 100 {
		err := InstallFederationRequestValidationError{
			field:  "FederationProjectCode",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetFederationClusterName()); l < 1 || l > 100 {
		err := InstallFederationRequestValidationError{
			field:  "FederationClusterName",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetFederationBusinessId()); l < 1 || l > 100 {
		err := InstallFederationRequestValidationError{
			field:  "FederationBusinessId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetFederationClusterEnv()); l < 1 || l > 100 {
		err := InstallFederationRequestValidationError{
			field:  "FederationClusterEnv",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetFederationClusterDescription()); l < 0 || l > 1024 {
		err := InstallFederationRequestValidationError{
			field:  "FederationClusterDescription",
			reason: "value length must be between 0 and 1024 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetFederationClusterLabels()) > 19 {
		err := InstallFederationRequestValidationError{
			field:  "FederationClusterLabels",
			reason: "value must contain no more than 19 pair(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InstallFederationRequestMultiError(errors)
	}

	return nil
}

// InstallFederationRequestMultiError is an error wrapping multiple validation
// errors returned by InstallFederationRequest.ValidateAll() if the designated
// constraints aren't met.
type InstallFederationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallFederationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallFederationRequestMultiError) AllErrors() []error { return m }

// InstallFederationRequestValidationError is the validation error returned by
// InstallFederationRequest.Validate if the designated constraints aren't met.
type InstallFederationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallFederationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallFederationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallFederationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallFederationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallFederationRequestValidationError) ErrorName() string {
	return "InstallFederationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InstallFederationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallFederationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallFederationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallFederationRequestValidationError{}

// Validate checks the field values on InstallFederationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InstallFederationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InstallFederationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InstallFederationResponseMultiError, or nil if none found.
func (m *InstallFederationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InstallFederationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstallFederationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstallFederationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstallFederationResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InstallFederationResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InstallFederationResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InstallFederationResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return InstallFederationResponseMultiError(errors)
	}

	return nil
}

// InstallFederationResponseMultiError is an error wrapping multiple validation
// errors returned by InstallFederationResponse.ValidateAll() if the
// designated constraints aren't met.
type InstallFederationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InstallFederationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InstallFederationResponseMultiError) AllErrors() []error { return m }

// InstallFederationResponseValidationError is the validation error returned by
// InstallFederationResponse.Validate if the designated constraints aren't met.
type InstallFederationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InstallFederationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InstallFederationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InstallFederationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InstallFederationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InstallFederationResponseValidationError) ErrorName() string {
	return "InstallFederationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InstallFederationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInstallFederationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InstallFederationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InstallFederationResponseValidationError{}

// Validate checks the field values on UnInstallFederationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnInstallFederationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnInstallFederationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnInstallFederationRequestMultiError, or nil if none found.
func (m *UnInstallFederationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UnInstallFederationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 1 || l > 100 {
		err := UnInstallFederationRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetOperator()); l < 1 || l > 100 {
		err := UnInstallFederationRequestValidationError{
			field:  "Operator",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UnInstallFederationRequestMultiError(errors)
	}

	return nil
}

// UnInstallFederationRequestMultiError is an error wrapping multiple
// validation errors returned by UnInstallFederationRequest.ValidateAll() if
// the designated constraints aren't met.
type UnInstallFederationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnInstallFederationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnInstallFederationRequestMultiError) AllErrors() []error { return m }

// UnInstallFederationRequestValidationError is the validation error returned
// by UnInstallFederationRequest.Validate if the designated constraints aren't met.
type UnInstallFederationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnInstallFederationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnInstallFederationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnInstallFederationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnInstallFederationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnInstallFederationRequestValidationError) ErrorName() string {
	return "UnInstallFederationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnInstallFederationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnInstallFederationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnInstallFederationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnInstallFederationRequestValidationError{}

// Validate checks the field values on UnInstallFederationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnInstallFederationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnInstallFederationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnInstallFederationResponseMultiError, or nil if none found.
func (m *UnInstallFederationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UnInstallFederationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnInstallFederationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnInstallFederationResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnInstallFederationResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnInstallFederationResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnInstallFederationResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnInstallFederationResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return UnInstallFederationResponseMultiError(errors)
	}

	return nil
}

// UnInstallFederationResponseMultiError is an error wrapping multiple
// validation errors returned by UnInstallFederationResponse.ValidateAll() if
// the designated constraints aren't met.
type UnInstallFederationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnInstallFederationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnInstallFederationResponseMultiError) AllErrors() []error { return m }

// UnInstallFederationResponseValidationError is the validation error returned
// by UnInstallFederationResponse.Validate if the designated constraints
// aren't met.
type UnInstallFederationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnInstallFederationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnInstallFederationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnInstallFederationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnInstallFederationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnInstallFederationResponseValidationError) ErrorName() string {
	return "UnInstallFederationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UnInstallFederationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnInstallFederationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnInstallFederationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnInstallFederationResponseValidationError{}

// Validate checks the field values on TaskDistributeResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TaskDistributeResponseData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskDistributeResponseData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskDistributeResponseDataMultiError, or nil if none found.
func (m *TaskDistributeResponseData) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskDistributeResponseData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TaskId

	if len(errors) > 0 {
		return TaskDistributeResponseDataMultiError(errors)
	}

	return nil
}

// TaskDistributeResponseDataMultiError is an error wrapping multiple
// validation errors returned by TaskDistributeResponseData.ValidateAll() if
// the designated constraints aren't met.
type TaskDistributeResponseDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskDistributeResponseDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskDistributeResponseDataMultiError) AllErrors() []error { return m }

// TaskDistributeResponseDataValidationError is the validation error returned
// by TaskDistributeResponseData.Validate if the designated constraints aren't met.
type TaskDistributeResponseDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskDistributeResponseDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskDistributeResponseDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskDistributeResponseDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskDistributeResponseDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskDistributeResponseDataValidationError) ErrorName() string {
	return "TaskDistributeResponseDataValidationError"
}

// Error satisfies the builtin error interface
func (e TaskDistributeResponseDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskDistributeResponseData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskDistributeResponseDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskDistributeResponseDataValidationError{}

// Validate checks the field values on RegisterSubclusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterSubclusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterSubclusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterSubclusterRequestMultiError, or nil if none found.
func (m *RegisterSubclusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterSubclusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 1 || l > 100 {
		err := RegisterSubclusterRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetCreator()); l < 1 || l > 100 {
		err := RegisterSubclusterRequestValidationError{
			field:  "Creator",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for UserToken

	if l := utf8.RuneCountInString(m.GetSubclusterId()); l < 1 || l > 100 {
		err := RegisterSubclusterRequestValidationError{
			field:  "SubclusterId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterSubclusterRequestMultiError(errors)
	}

	return nil
}

// RegisterSubclusterRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterSubclusterRequest.ValidateAll() if the
// designated constraints aren't met.
type RegisterSubclusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterSubclusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterSubclusterRequestMultiError) AllErrors() []error { return m }

// RegisterSubclusterRequestValidationError is the validation error returned by
// RegisterSubclusterRequest.Validate if the designated constraints aren't met.
type RegisterSubclusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterSubclusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterSubclusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterSubclusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterSubclusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterSubclusterRequestValidationError) ErrorName() string {
	return "RegisterSubclusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterSubclusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterSubclusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterSubclusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterSubclusterRequestValidationError{}

// Validate checks the field values on RegisterSubclusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterSubclusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterSubclusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterSubclusterResponseMultiError, or nil if none found.
func (m *RegisterSubclusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterSubclusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterSubclusterResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterSubclusterResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterSubclusterResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterSubclusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterSubclusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterSubclusterResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return RegisterSubclusterResponseMultiError(errors)
	}

	return nil
}

// RegisterSubclusterResponseMultiError is an error wrapping multiple
// validation errors returned by RegisterSubclusterResponse.ValidateAll() if
// the designated constraints aren't met.
type RegisterSubclusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterSubclusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterSubclusterResponseMultiError) AllErrors() []error { return m }

// RegisterSubclusterResponseValidationError is the validation error returned
// by RegisterSubclusterResponse.Validate if the designated constraints aren't met.
type RegisterSubclusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterSubclusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterSubclusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterSubclusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterSubclusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterSubclusterResponseValidationError) ErrorName() string {
	return "RegisterSubclusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterSubclusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterSubclusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterSubclusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterSubclusterResponseValidationError{}

// Validate checks the field values on RemoveSubclusterRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveSubclusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveSubclusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveSubclusterRequestMultiError, or nil if none found.
func (m *RemoveSubclusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveSubclusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetClusterId()); l < 1 || l > 100 {
		err := RemoveSubclusterRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetSubclusterId()); l < 1 || l > 100 {
		err := RemoveSubclusterRequestValidationError{
			field:  "SubclusterId",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetUser()); l < 1 || l > 100 {
		err := RemoveSubclusterRequestValidationError{
			field:  "User",
			reason: "value length must be between 1 and 100 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RemoveSubclusterRequestMultiError(errors)
	}

	return nil
}

// RemoveSubclusterRequestMultiError is an error wrapping multiple validation
// errors returned by RemoveSubclusterRequest.ValidateAll() if the designated
// constraints aren't met.
type RemoveSubclusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveSubclusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveSubclusterRequestMultiError) AllErrors() []error { return m }

// RemoveSubclusterRequestValidationError is the validation error returned by
// RemoveSubclusterRequest.Validate if the designated constraints aren't met.
type RemoveSubclusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveSubclusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveSubclusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveSubclusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveSubclusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveSubclusterRequestValidationError) ErrorName() string {
	return "RemoveSubclusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveSubclusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveSubclusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveSubclusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveSubclusterRequestValidationError{}

// Validate checks the field values on RemoveSubclusterResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RemoveSubclusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RemoveSubclusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RemoveSubclusterResponseMultiError, or nil if none found.
func (m *RemoveSubclusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RemoveSubclusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RemoveSubclusterResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RemoveSubclusterResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RemoveSubclusterResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RemoveSubclusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RemoveSubclusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RemoveSubclusterResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return RemoveSubclusterResponseMultiError(errors)
	}

	return nil
}

// RemoveSubclusterResponseMultiError is an error wrapping multiple validation
// errors returned by RemoveSubclusterResponse.ValidateAll() if the designated
// constraints aren't met.
type RemoveSubclusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveSubclusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveSubclusterResponseMultiError) AllErrors() []error { return m }

// RemoveSubclusterResponseValidationError is the validation error returned by
// RemoveSubclusterResponse.Validate if the designated constraints aren't met.
type RemoveSubclusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveSubclusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveSubclusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveSubclusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveSubclusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveSubclusterResponseValidationError) ErrorName() string {
	return "RemoveSubclusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveSubclusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveSubclusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveSubclusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveSubclusterResponseValidationError{}

// Validate checks the field values on GetFederationClusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFederationClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFederationClusterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFederationClusterRequestMultiError, or nil if none found.
func (m *GetFederationClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFederationClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterId()) < 1 {
		err := GetFederationClusterRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetFederationClusterRequestMultiError(errors)
	}

	return nil
}

// GetFederationClusterRequestMultiError is an error wrapping multiple
// validation errors returned by GetFederationClusterRequest.ValidateAll() if
// the designated constraints aren't met.
type GetFederationClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFederationClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFederationClusterRequestMultiError) AllErrors() []error { return m }

// GetFederationClusterRequestValidationError is the validation error returned
// by GetFederationClusterRequest.Validate if the designated constraints
// aren't met.
type GetFederationClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFederationClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFederationClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFederationClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFederationClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFederationClusterRequestValidationError) ErrorName() string {
	return "GetFederationClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFederationClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFederationClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFederationClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFederationClusterRequestValidationError{}

// Validate checks the field values on GetFederationClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetFederationClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFederationClusterResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFederationClusterResponseMultiError, or nil if none found.
func (m *GetFederationClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFederationClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFederationClusterResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFederationClusterResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFederationClusterResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFederationClusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFederationClusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFederationClusterResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return GetFederationClusterResponseMultiError(errors)
	}

	return nil
}

// GetFederationClusterResponseMultiError is an error wrapping multiple
// validation errors returned by GetFederationClusterResponse.ValidateAll() if
// the designated constraints aren't met.
type GetFederationClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFederationClusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFederationClusterResponseMultiError) AllErrors() []error { return m }

// GetFederationClusterResponseValidationError is the validation error returned
// by GetFederationClusterResponse.Validate if the designated constraints
// aren't met.
type GetFederationClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFederationClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFederationClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFederationClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFederationClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFederationClusterResponseValidationError) ErrorName() string {
	return "GetFederationClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFederationClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFederationClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFederationClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFederationClusterResponseValidationError{}

// Validate checks the field values on GetFederationByHostClusterRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetFederationByHostClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFederationByHostClusterRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetFederationByHostClusterRequestMultiError, or nil if none found.
func (m *GetFederationByHostClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFederationByHostClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterId()) < 1 {
		err := GetFederationByHostClusterRequestValidationError{
			field:  "ClusterId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetFederationByHostClusterRequestMultiError(errors)
	}

	return nil
}

// GetFederationByHostClusterRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetFederationByHostClusterRequest.ValidateAll() if the designated
// constraints aren't met.
type GetFederationByHostClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFederationByHostClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFederationByHostClusterRequestMultiError) AllErrors() []error { return m }

// GetFederationByHostClusterRequestValidationError is the validation error
// returned by GetFederationByHostClusterRequest.Validate if the designated
// constraints aren't met.
type GetFederationByHostClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFederationByHostClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFederationByHostClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFederationByHostClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFederationByHostClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFederationByHostClusterRequestValidationError) ErrorName() string {
	return "GetFederationByHostClusterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFederationByHostClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFederationByHostClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFederationByHostClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFederationByHostClusterRequestValidationError{}

// Validate checks the field values on GetFederationByHostClusterResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetFederationByHostClusterResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFederationByHostClusterResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetFederationByHostClusterResponseMultiError, or nil if none found.
func (m *GetFederationByHostClusterResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFederationByHostClusterResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFederationByHostClusterResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFederationByHostClusterResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFederationByHostClusterResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFederationByHostClusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFederationByHostClusterResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFederationByHostClusterResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return GetFederationByHostClusterResponseMultiError(errors)
	}

	return nil
}

// GetFederationByHostClusterResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetFederationByHostClusterResponse.ValidateAll() if the designated
// constraints aren't met.
type GetFederationByHostClusterResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFederationByHostClusterResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFederationByHostClusterResponseMultiError) AllErrors() []error { return m }

// GetFederationByHostClusterResponseValidationError is the validation error
// returned by GetFederationByHostClusterResponse.Validate if the designated
// constraints aren't met.
type GetFederationByHostClusterResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFederationByHostClusterResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFederationByHostClusterResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFederationByHostClusterResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFederationByHostClusterResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFederationByHostClusterResponseValidationError) ErrorName() string {
	return "GetFederationByHostClusterResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetFederationByHostClusterResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFederationByHostClusterResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFederationByHostClusterResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFederationByHostClusterResponseValidationError{}

// Validate checks the field values on ListProjectInstallingFederationRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListProjectInstallingFederationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListProjectInstallingFederationRequest with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListProjectInstallingFederationRequestMultiError, or nil if none found.
func (m *ListProjectInstallingFederationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectInstallingFederationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectId()) < 1 {
		err := ListProjectInstallingFederationRequestValidationError{
			field:  "ProjectId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListProjectInstallingFederationRequestMultiError(errors)
	}

	return nil
}

// ListProjectInstallingFederationRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListProjectInstallingFederationRequest.ValidateAll() if the designated
// constraints aren't met.
type ListProjectInstallingFederationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectInstallingFederationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectInstallingFederationRequestMultiError) AllErrors() []error { return m }

// ListProjectInstallingFederationRequestValidationError is the validation
// error returned by ListProjectInstallingFederationRequest.Validate if the
// designated constraints aren't met.
type ListProjectInstallingFederationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectInstallingFederationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectInstallingFederationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectInstallingFederationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectInstallingFederationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectInstallingFederationRequestValidationError) ErrorName() string {
	return "ListProjectInstallingFederationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectInstallingFederationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectInstallingFederationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectInstallingFederationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectInstallingFederationRequestValidationError{}

// Validate checks the field values on ListProjectInstallingFederationResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ListProjectInstallingFederationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ListProjectInstallingFederationResponse with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// ListProjectInstallingFederationResponseMultiError, or nil if none found.
func (m *ListProjectInstallingFederationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectInstallingFederationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProjectInstallingFederationResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProjectInstallingFederationResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProjectInstallingFederationResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProjectInstallingFederationResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProjectInstallingFederationResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProjectInstallingFederationResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return ListProjectInstallingFederationResponseMultiError(errors)
	}

	return nil
}

// ListProjectInstallingFederationResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListProjectInstallingFederationResponse.ValidateAll() if the designated
// constraints aren't met.
type ListProjectInstallingFederationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectInstallingFederationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectInstallingFederationResponseMultiError) AllErrors() []error { return m }

// ListProjectInstallingFederationResponseValidationError is the validation
// error returned by ListProjectInstallingFederationResponse.Validate if the
// designated constraints aren't met.
type ListProjectInstallingFederationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectInstallingFederationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectInstallingFederationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectInstallingFederationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectInstallingFederationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectInstallingFederationResponseValidationError) ErrorName() string {
	return "ListProjectInstallingFederationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectInstallingFederationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectInstallingFederationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectInstallingFederationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectInstallingFederationResponseValidationError{}

// Validate checks the field values on ListProjectFederationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectFederationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectFederationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectFederationRequestMultiError, or nil if none found.
func (m *ListProjectFederationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectFederationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProjectId()) < 1 {
		err := ListProjectFederationRequestValidationError{
			field:  "ProjectId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListProjectFederationRequestMultiError(errors)
	}

	return nil
}

// ListProjectFederationRequestMultiError is an error wrapping multiple
// validation errors returned by ListProjectFederationRequest.ValidateAll() if
// the designated constraints aren't met.
type ListProjectFederationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectFederationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectFederationRequestMultiError) AllErrors() []error { return m }

// ListProjectFederationRequestValidationError is the validation error returned
// by ListProjectFederationRequest.Validate if the designated constraints
// aren't met.
type ListProjectFederationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectFederationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectFederationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectFederationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectFederationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectFederationRequestValidationError) ErrorName() string {
	return "ListProjectFederationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectFederationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectFederationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectFederationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectFederationRequestValidationError{}

// Validate checks the field values on ListProjectFederationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectFederationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectFederationResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ListProjectFederationResponseMultiError, or nil if none found.
func (m *ListProjectFederationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectFederationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListProjectFederationResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListProjectFederationResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListProjectFederationResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetWebAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListProjectFederationResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListProjectFederationResponseValidationError{
					field:  "WebAnnotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWebAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListProjectFederationResponseValidationError{
				field:  "WebAnnotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Code != nil {
		// no validation rules for Code
	}

	if len(errors) > 0 {
		return ListProjectFederationResponseMultiError(errors)
	}

	return nil
}

// ListProjectFederationResponseMultiError is an error wrapping multiple
// validation errors returned by ListProjectFederationResponse.ValidateAll()
// if the designated constraints aren't met.
type ListProjectFederationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectFederationResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectFederationResponseMultiError) AllErrors() []error { return m }

// ListProjectFederationResponseValidationError is the validation error
// returned by ListProjectFederationResponse.Validate if the designated
// constraints aren't met.
type ListProjectFederationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectFederationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectFederationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectFederationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectFederationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectFederationResponseValidationError) ErrorName() string {
	return "ListProjectFederationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectFederationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectFederationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectFederationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectFederationResponseValidationError{}

// Validate checks the field values on FederationClusterWithTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FederationClusterWithTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FederationClusterWithTask with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FederationClusterWithTaskMultiError, or nil if none found.
func (m *FederationClusterWithTask) ValidateAll() error {
	return m.validate(true)
}

func (m *FederationClusterWithTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCluster()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FederationClusterWithTaskValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FederationClusterWithTaskValidationError{
					field:  "Cluster",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCluster()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FederationClusterWithTaskValidationError{
				field:  "Cluster",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FederationClusterWithTaskValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FederationClusterWithTaskValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FederationClusterWithTaskValidationError{
				field:  "Task",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FederationClusterWithTaskMultiError(errors)
	}

	return nil
}

// FederationClusterWithTaskMultiError is an error wrapping multiple validation
// errors returned by FederationClusterWithTask.ValidateAll() if the
// designated constraints aren't met.
type FederationClusterWithTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FederationClusterWithTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FederationClusterWithTaskMultiError) AllErrors() []error { return m }

// FederationClusterWithTaskValidationError is the validation error returned by
// FederationClusterWithTask.Validate if the designated constraints aren't met.
type FederationClusterWithTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FederationClusterWithTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FederationClusterWithTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FederationClusterWithTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FederationClusterWithTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FederationClusterWithTaskValidationError) ErrorName() string {
	return "FederationClusterWithTaskValidationError"
}

// Error satisfies the builtin error interface
func (e FederationClusterWithTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFederationClusterWithTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FederationClusterWithTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FederationClusterWithTaskValidationError{}

// Validate checks the field values on FederationCluster with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FederationCluster) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FederationCluster with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FederationClusterMultiError, or nil if none found.
func (m *FederationCluster) ValidateAll() error {
	return m.validate(true)
}

func (m *FederationCluster) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FederationClusterId

	// no validation rules for FederationClusterName

	// no validation rules for HostClusterId

	// no validation rules for ProjectCode

	// no validation rules for ProjectId

	// no validation rules for CreatedTime

	// no validation rules for UpdatedTime

	// no validation rules for Status

	for idx, item := range m.GetSubClusters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FederationClusterValidationError{
						field:  fmt.Sprintf("SubClusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FederationClusterValidationError{
						field:  fmt.Sprintf("SubClusters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FederationClusterValidationError{
					field:  fmt.Sprintf("SubClusters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFederationNamespaces() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FederationClusterValidationError{
						field:  fmt.Sprintf("FederationNamespaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FederationClusterValidationError{
						field:  fmt.Sprintf("FederationNamespaces[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FederationClusterValidationError{
					field:  fmt.Sprintf("FederationNamespaces[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FederationClusterMultiError(errors)
	}

	return nil
}

// FederationClusterMultiError is an error wrapping multiple validation errors
// returned by FederationCluster.ValidateAll() if the designated constraints
// aren't met.
type FederationClusterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FederationClusterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FederationClusterMultiError) AllErrors() []error { return m }

// FederationClusterValidationError is the validation error returned by
// FederationCluster.Validate if the designated constraints aren't met.
type FederationClusterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FederationClusterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FederationClusterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FederationClusterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FederationClusterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FederationClusterValidationError) ErrorName() string {
	return "FederationClusterValidationError"
}

// Error satisfies the builtin error interface
func (e FederationClusterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFederationCluster.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FederationClusterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FederationClusterValidationError{}
